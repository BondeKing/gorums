// Go support for Protocol Buffers - Google's data interchange format
//
// Copyright 2015 The Go Authors.  All rights reserved.
// https://github.com/golang/protobuf
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Package gorums outputs a gorums client API in Go code.
// It runs as a plugin for the Go protocol buffer compiler plugin.
// It is linked in to protoc-gen-go.
package gorums

import (
	"bytes"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	pb "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
)

func init() {
	generator.RegisterPlugin(new(gorums))
}

// gorums is an implementation of the Go protocol buffer compiler's
// plugin architecture.  It generates bindings for gorums support.
type gorums struct {
	gen *generator.Generator
}

// Name returns the name of this plugin, "gorums".
func (g *gorums) Name() string {
	return "gorums"
}

// Init initializes the plugin.
func (g *gorums) Init(gen *generator.Generator) {
	g.gen = gen
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (g *gorums) objectNamed(name string) generator.Object {
	g.gen.RecordTypeUse(name)
	return g.gen.ObjectNamed(name)
}

// Given a type name defined in a .proto, return its name as we will print it.
func (g *gorums) typeName(str string) string {
	return g.gen.TypeName(g.objectNamed(str))
}

// P forwards to g.gen.P.
func (g *gorums) P(args ...interface{}) { g.gen.P(args...) }

// visit generates a _gen.go file if the supplied path is an .tmpl file.
// Note that the function rely on data in global variable pkgData.
func visit(path string, f os.FileInfo, err error) error {
	if strings.HasSuffix(path, ".tmpl") {
		name := strings.TrimSuffix(path, ".tmpl")
		log.Println("Processing: " + path)
		// Create a new template and parse the service data into it.
		t := template.Must(template.ParseFiles(path))

		// Create .go file for writing the template and data into.
		w, err := os.Create(name + "_gen.xo") //TODO fix .xo->.go
		if err != nil {
			return err
		}
		w.WriteString("// DO NOT EDIT. Generated by Gorums Protobuf plugin\n")
		w.WriteString("// Source file to edit is: " + path + "\n")

		pkgData.IgnoreImports = false
		// Execute the template for each service method and arguments.
		err = t.Execute(w, pkgData)
		if err != nil {
			log.Println("executing template:", err)
		}

		pkgData.IgnoreImports = true
		wb := new(bytes.Buffer)
		err = t.Execute(wb, pkgData)
		if err != nil {
			log.Println("executing template:", err)
		}
		gg.P()
		gg.P("/* Gorums Generator Plugin - generated from: ", path, " */")
		gg.P()
		gg.P(wb.String())
	}
	return nil
}

var gg *gorums

type tmplData struct {
	PackageName   string
	Services      []serviceMethod
	IgnoreImports bool
}

var pkgData tmplData

// Generate generates code for the services in the given file.
func (g *gorums) Generate(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	pkgData = tmplData{
		PackageName:   file.GetPackage(),
		Services:      g.generateServiceMethods(file.FileDescriptorProto.Service),
		IgnoreImports: false,
	}
	gg = g
	err := filepath.Walk(pkgData.PackageName, visit)
	if err != nil {
		log.Fatal(err)
	}

	g.embedStaticResources()
}

// GenerateImports generates the import declaration for this file.
func (g *gorums) GenerateImports(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	if len(staticImports) == 0 {
		return
	}

	sort.Strings(staticImports)
	g.P("import (")
	for _, simport := range staticImports {
		if ignore := ignoreImport[simport]; ignore {
			continue
		}
		g.P("\"", simport, "\"")
	}
	if !onlyClientStreamMethods(file.FileDescriptorProto.Service) {
		g.P()
		g.P("\"google.golang.org/grpc/codes\"")
	}
	g.P(")")
}

var ignoreImport = map[string]bool{
	"fmt":  true,
	"math": true,
	"golang.org/x/net/context": true,
	"google.golang.org/grpc":   true,
}

func onlyClientStreamMethods(services []*pb.ServiceDescriptorProto) bool {
	for _, service := range services {
		for _, method := range service.Method {
			if !method.GetClientStreaming() {
				return false
			}
		}

	}
	return true
}

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }

func (g *gorums) embedStaticResources() {
	g.P("/* Static resources */")
	g.P(staticResources)
}

type serviceMethod struct {
	OrigName             string
	MethodName           string
	UnexportedMethodName string
	RPCName              string

	RespName string
	ReqName  string

	TypeName           string
	UnexportedTypeName string

	Streaming bool

	ServName string // Redundant, but keeps it simple.
}

type smSlice []serviceMethod

func (p smSlice) Len() int      { return len(p) }
func (p smSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
func (p smSlice) Less(i, j int) bool {
	if p[i].ServName < p[j].ServName {
		return true
	} else if p[i].ServName > p[j].ServName {
		return false
	} else {
		if p[i].OrigName < p[j].OrigName {
			return true
		} else if p[i].OrigName > p[j].OrigName {
			return false
		} else {
			return false
		}
	}
}

func (g *gorums) generateServiceMethods(services []*pb.ServiceDescriptorProto) []serviceMethod {
	smethods := make(map[string][]*serviceMethod)
	for _, service := range services {
		for _, method := range service.Method {
			log.Println(method.GetName())

			if method.GetServerStreaming() {
				log.Fatalf(
					"%s - %s: server streaming not supported by gorums",
					service.GetName(), method.GetName())
			}

			sm := serviceMethod{}
			sm.OrigName = method.GetName()
			sm.MethodName = generator.CamelCase(sm.OrigName)
			sm.RPCName = sm.MethodName // sm.MethodName may be overwritten if method name conflict
			sm.UnexportedMethodName = unexport(sm.MethodName)
			sm.RespName = g.typeName(method.GetOutputType())
			sm.ReqName = g.typeName(method.GetInputType())
			sm.TypeName = sm.MethodName + "Reply"
			sm.UnexportedTypeName = unexport(sm.TypeName)
			sm.ServName = service.GetName()

			if sm.TypeName == sm.RespName {
				sm.TypeName += "_"
			}

			if method.GetClientStreaming() {
				sm.Streaming = true
			}

			methodsForName, _ := smethods[sm.MethodName]
			methodsForName = append(methodsForName, &sm)
			smethods[sm.MethodName] = methodsForName
		}
	}

	var allRewrittenFlat []serviceMethod

	for _, methodsForName := range smethods {
		switch len(methodsForName) {
		case 0:
			panic("generateServiceMethods: found method name with no data")
		case 1:
			allRewrittenFlat = append(allRewrittenFlat, *methodsForName[0])
			continue
		default:
			for _, sm := range methodsForName {
				sm.OrigName = sm.ServName + sm.OrigName
				sm.MethodName = sm.ServName + sm.MethodName
				sm.UnexportedMethodName = unexport(sm.MethodName)
				sm.TypeName = sm.MethodName + "Reply"
				sm.UnexportedTypeName = unexport(sm.TypeName)
				if sm.TypeName == sm.RespName {
					sm.TypeName += "_"
				}
				allRewrittenFlat = append(allRewrittenFlat, *sm)
			}
		}
	}

	sort.Sort(smSlice(allRewrittenFlat))

	return allRewrittenFlat
}
