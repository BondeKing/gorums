// Go support for Protocol Buffers - Google's data interchange format
//
// Copyright 2015 The Go Authors.  All rights reserved.
// https://github.com/golang/protobuf
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Package gorums outputs a gorums client API in Go code.
// It runs as a plugin for the Go protocol buffer compiler plugin.
// It is linked in to protoc-gen-gorums.
package gorums

import (
	"bytes"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	pb "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
)

func init() {
	generator.RegisterPlugin(new(gorums))
}

// gorums is an implementation of the Go protocol buffer compiler's
// plugin architecture.  It generates bindings for gorums support.
type gorums struct {
	gen *generator.Generator
}

// Name returns the name of this plugin, "gorums".
func (g *gorums) Name() string {
	return "gorums"
}

// Init initializes the plugin.
func (g *gorums) Init(gen *generator.Generator) {
	g.gen = gen
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (g *gorums) objectNamed(name string) generator.Object {
	g.gen.RecordTypeUse(name)
	return g.gen.ObjectNamed(name)
}

// Given a type name defined in a .proto, return its name as we will print it.
func (g *gorums) typeName(str string) string {
	return g.gen.TypeName(g.objectNamed(str))
}

// P forwards to g.gen.P.
func (g *gorums) P(args ...interface{}) { g.gen.P(args...) }

// Generate generates code for the services in the given file.
func (g *gorums) Generate(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	pkgData := struct {
		PackageName   string
		Services      []serviceMethod
		IgnoreImports bool
	}{
		PackageName:   file.GetPackage(),
		Services:      g.generateServiceMethods(file.FileDescriptorProto.Service),
		IgnoreImports: true,
	}
	for name, tmpl := range templates {
		// Create a new template and parse the service data into it.
		t := template.Must(template.New(name).Parse(tmpl))
		w := new(bytes.Buffer)
		pkgData.IgnoreImports = true
		err := t.Execute(w, pkgData)
		if err != nil {
			log.Println("executing template:", err)
		}
		g.P()
		g.P("/* Gorums Generator Plugin - generated from: ", name, " */")
		g.P()
		g.P(w.String())

		// Only overwrite _gen.go files if GORUMSGEN set to 1
		if os.Getenv("GORUMSGEN") != "1" {
			continue
		}

		// Generate files in dev for editing
		pkgData.IgnoreImports = false
		wb := new(bytes.Buffer)
		wb.WriteString("// DO NOT EDIT. Generated by Gorums Protobuf plugin\n")
		wb.WriteString("// Source file to edit is: " + name + "\n")
		// Execute the template for each service method and arguments.
		err = t.Execute(wb, pkgData)
		if err != nil {
			log.Println("executing template:", err)
		}
		dst, err := format.Source(wb.Bytes())
		if err != nil {
			log.Println("formating code:", err)
		}
		genfile := filepath.Join(pkgData.PackageName, strings.Replace(name, "_tmpl", "_gen.go", 1))
		log.Println("writing: " + genfile)
		// Create .go file for writing the template and data into.
		if err = ioutil.WriteFile(genfile, dst, 0644); err != nil {
			log.Println("writing file:", err)
		}
	}

	g.embedStaticResources()
}

// GenerateImports generates the import declaration for this file.
func (g *gorums) GenerateImports(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}
	if len(staticImports) == 0 {
		return
	}

	sort.Strings(staticImports)
	g.P("import (")
	for _, simport := range staticImports {
		if ignore := ignoreImport[simport]; ignore {
			continue
		}
		g.P("\"", simport, "\"")
	}
	if !onlyClientStreamMethods(file.FileDescriptorProto.Service) {
		g.P()
		g.P("\"google.golang.org/grpc/codes\"")
	}
	g.P(")")
}

var ignoreImport = map[string]bool{
	"fmt":  true,
	"math": true,
	"golang.org/x/net/context": true,
	"google.golang.org/grpc":   true,
}

func onlyClientStreamMethods(services []*pb.ServiceDescriptorProto) bool {
	for _, service := range services {
		for _, method := range service.Method {
			if !method.GetClientStreaming() {
				return false
			}
		}

	}
	return true
}

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }

func (g *gorums) embedStaticResources() {
	g.P("/* Static resources */")
	g.P(staticResources)
}

type serviceMethod struct {
	OrigName             string
	MethodName           string
	UnexportedMethodName string
	RPCName              string

	RespName string
	ReqName  string

	TypeName           string
	UnexportedTypeName string

	Streaming bool

	ServName string // Redundant, but keeps it simple.
}

type smSlice []serviceMethod

func (p smSlice) Len() int      { return len(p) }
func (p smSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
func (p smSlice) Less(i, j int) bool {
	if p[i].ServName < p[j].ServName {
		return true
	} else if p[i].ServName > p[j].ServName {
		return false
	} else {
		if p[i].OrigName < p[j].OrigName {
			return true
		} else if p[i].OrigName > p[j].OrigName {
			return false
		} else {
			return false
		}
	}
}

func (g *gorums) generateServiceMethods(services []*pb.ServiceDescriptorProto) []serviceMethod {
	smethods := make(map[string][]*serviceMethod)
	for _, service := range services {
		for _, method := range service.Method {
			log.Println(method.GetName())

			if method.GetServerStreaming() {
				log.Fatalf(
					"%s - %s: server streaming not supported by gorums",
					service.GetName(), method.GetName())
			}

			sm := serviceMethod{}
			sm.OrigName = method.GetName()
			sm.MethodName = generator.CamelCase(sm.OrigName)
			sm.RPCName = sm.MethodName // sm.MethodName may be overwritten if method name conflict
			sm.UnexportedMethodName = unexport(sm.MethodName)
			sm.RespName = g.typeName(method.GetOutputType())
			sm.ReqName = g.typeName(method.GetInputType())
			sm.TypeName = sm.MethodName + "Reply"
			sm.UnexportedTypeName = unexport(sm.TypeName)
			sm.ServName = service.GetName()

			if sm.TypeName == sm.RespName {
				sm.TypeName += "_"
			}

			if method.GetClientStreaming() {
				sm.Streaming = true
			}

			methodsForName, _ := smethods[sm.MethodName]
			methodsForName = append(methodsForName, &sm)
			smethods[sm.MethodName] = methodsForName
		}
	}

	var allRewrittenFlat []serviceMethod

	for _, methodsForName := range smethods {
		switch len(methodsForName) {
		case 0:
			panic("generateServiceMethods: found method name with no data")
		case 1:
			allRewrittenFlat = append(allRewrittenFlat, *methodsForName[0])
			continue
		default:
			for _, sm := range methodsForName {
				sm.OrigName = sm.ServName + sm.OrigName
				sm.MethodName = sm.ServName + sm.MethodName
				sm.UnexportedMethodName = unexport(sm.MethodName)
				sm.TypeName = sm.MethodName + "Reply"
				sm.UnexportedTypeName = unexport(sm.TypeName)
				if sm.TypeName == sm.RespName {
					sm.TypeName += "_"
				}
				allRewrittenFlat = append(allRewrittenFlat, *sm)
			}
		}
	}

	sort.Sort(smSlice(allRewrittenFlat))

	return allRewrittenFlat
}
