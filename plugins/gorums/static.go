// DO NOT EDIT. Generated by github.com/relab/gorums/cmd/bundle
// bundle github.com/relab/gorums/dev

package gorums

var staticImports = []string{
	"fmt",
	"log",
	"google.golang.org/grpc",
	"sort",
	"sync",
	"net",
	"hash/fnv",
	"encoding/binary",
	"time",
}

const staticResources = `
/* config.go */

// A Configuration represents a static set of nodes on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id	int
	gid	uint32
	nodes	[]int
	mgr	*Manager
	quorum	int
	timeout	time.Duration
}

// ID reports the local identifier for the configuration.
func (c *Configuration) ID() int {
	return c.id
}

// GlobalID reports the unique global identifier for the configuration.
func (c *Configuration) GlobalID() uint32 {
	return c.gid
}

// Nodes returns a slice containing the local ids of all the nodes in the
// configuration.
func (c *Configuration) Nodes() []int	{ return c.nodes }

// Quorum returns the quourm size for the configuration.
func (c *Configuration) Quorum() int {
	return c.quorum
}

// Size returns the number of nodes in the configuration.
func (c *Configuration) Size() int {
	return len(c.nodes)
}

func (c *Configuration) String() string {
	return fmt.Sprintf("configuration %d | gid: %d", c.id, c.gid)
}

// Equal returns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool	{ return a.gid == b.gid }

// NewTestConfiguration returns a new configuration with quorum size q and
// node size n. No other fields are set. Configurations returned from this
// constructor should only be used when testing quorum functions.
func NewTestConfiguration(q, n int) *Configuration {
	return &Configuration{
		quorum:	q,
		nodes:	make([]int, n),
	}
}

/* errors.go */

// A NodeNotFoundError reports that a specified node could not be found.
type NodeNotFoundError uint32

func (e NodeNotFoundError) Error() string {
	return fmt.Sprintf("node not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IncompleteRPCError reports that a quorum RPC call failed.
type IncompleteRPCError struct {
	ErrCount, ReplyCount int
}

func (e IncompleteRPCError) Error() string {
	return fmt.Sprintf(
		"incomplete rpc (errors: %d, replies: %d)",
		e.ErrCount, e.ReplyCount,
	)
}

// An TimeoutRPCError reports that a quorum RPC call timed out.
type TimeoutRPCError struct {
	Waited			time.Duration
	ErrCount, RepliesCount	int
}

func (e TimeoutRPCError) Error() string {
	return fmt.Sprintf(
		"rpc timed out: waited %v (errors: %d, replies: %d)",
		e.Waited, e.ErrCount, e.RepliesCount,
	)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

// ManagerCreationError returns an error reporting that a Manager could not be
// created due to err.
func ManagerCreationError(err error) error {
	return fmt.Errorf("could not create manager: %s", err.Error())
}

/* mgr.go */

// NewManager attempts to connect to the given set of node addresses and if
// successful returns a new Manager containing connections to those nodes.
func NewManager(nodeAddrs []string, opts ...ManagerOption) (*Manager, error) {
	if len(nodeAddrs) == 0 {
		return nil, fmt.Errorf("could not create manager: no nodes provided")
	}

	m := new(Manager)
	m.nodeGidToID = make(map[uint32]int)
	m.configGidToID = make(map[uint32]int)

	for _, opt := range opts {
		opt(&m.opts)
	}

	selfAddrIndex, selfGid, err := m.parseSelfOptions(nodeAddrs)
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	gidSeen := false
	for i, naddr := range nodeAddrs {
		node, err2 := m.createNode(naddr)
		if err2 != nil {
			return nil, ManagerCreationError(err)
		}
		m.nodes = append(m.nodes, node)
		if i == selfAddrIndex {
			node.self = true
			continue
		}
		if node.gid == selfGid {
			node.self = true
			gidSeen = true
		}
	}
	if selfGid != 0 && !gidSeen {
		return nil, ManagerCreationError(
			fmt.Errorf("WithSelfGid provided, but no node with gid %d found", selfGid),
		)
	}

	OrderedBy(GlobalID).Sort(m.nodes)

	for i, node := range m.nodes {
		node.id = i
		m.nodeGidToID[node.gid] = node.id
	}

	err = m.connectAll()
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	err = m.createStreamClients()
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	if m.opts.logger != nil {
		m.logger = m.opts.logger
	}

	m.setDefaultQuorumFuncs()

	return m, nil
}

func (m *Manager) parseSelfOptions(addrs []string) (int, uint32, error) {
	if m.opts.selfAddr != "" && m.opts.selfGid != 0 {
		return 0, 0, fmt.Errorf("both WithSelfAddr and WithSelfGid provided")
	}
	if m.opts.selfGid != 0 {
		return -1, m.opts.selfGid, nil
	}
	if m.opts.selfAddr == "" {
		return -1, 0, nil
	}

	seen, index := contains(m.opts.selfAddr, addrs)
	if !seen {
		return 0, 0, fmt.Errorf(
			"option WithSelfAddr provided, but address %q was not present in address list",
			m.opts.selfAddr)
	}

	return index, 0, nil
}

func (m *Manager) createNode(addr string) (*Node, error) {
	m.Lock()
	defer m.Unlock()

	tcpAddr, err := net.ResolveTCPAddr("tcp", addr)
	if err != nil {
		return nil, fmt.Errorf("create node %s error: %v", addr, err)
	}

	h := fnv.New32a()
	_, _ = h.Write([]byte(tcpAddr.String()))
	gid := h.Sum32()

	if _, nodeExists := m.nodeGidToID[gid]; nodeExists {
		return nil, fmt.Errorf("create node %s error: node already exists", addr)
	}

	node := &Node{
		gid:		gid,
		addr:		tcpAddr.String(),
		latency:	-1 * time.Second,
	}

	m.nodeGidToID[gid] = -1

	return node, nil
}

func (m *Manager) connectAll() error {
	if m.opts.noConnect {
		return nil
	}
	for _, node := range m.nodes {
		if node.self {
			continue
		}
		err := node.connect(m.opts.grpcDialOpts...)
		if err != nil {
			return fmt.Errorf("connect node %s error: %v", node.addr, err)
		}
	}
	return nil
}

func (m *Manager) closeNodeConns() {
	for _, node := range m.nodes {
		if node.self {
			continue
		}
		err := node.conn.Close()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("node %d: error closing connection: %v", node.id, err)
		}
	}
}

// Close closes all node connections and any client streams.
func (m *Manager) Close() {
	m.closeOnce.Do(func() {
		m.closeStreamClients()
		m.closeNodeConns()
	})
}

// NodeIDs returns the identifier of each available node.
func (m *Manager) NodeIDs() []int {
	m.RLock()
	defer m.RUnlock()
	ids := make([]int, len(m.nodes))
	for i := range m.nodes {
		ids[i] = i
	}
	return ids
}

// NodeGlobalIDs returns the global identifier of each available node.
func (m *Manager) NodeGlobalIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	gids := make([]uint32, len(m.nodeGidToID))
	for gid, id := range m.nodeGidToID {
		gids[id] = gid
	}
	return gids
}

// Node returns the node with the given local identifier if present.
func (m *Manager) Node(id int) (node *Node, found bool) {
	m.RLock()
	defer m.RUnlock()
	if id < 0 || id >= len(m.nodes) {
		return nil, false
	}
	node = m.nodes[id]
	if node == nil {
		return nil, false
	}
	return node, true
}

// NodeFromGlobalID returns the node with the given global identifier if
// present.
func (m *Manager) NodeFromGlobalID(gid uint32) (node *Node, found bool) {
	m.RLock()
	defer m.RUnlock()
	localID, found := m.nodeGidToID[gid]
	if !found {
		return nil, false
	}
	return m.Node(localID)
}

// Nodes returns a slice of each available node.
func (m *Manager) Nodes(excludeSelf bool) []*Node {
	m.RLock()
	defer m.RUnlock()
	var nodes []*Node
	for _, node := range m.nodes {
		if excludeSelf && node.self {
			continue
		}
		nodes = append(nodes, node)
	}
	return nodes
}

// ConfigurationIDs returns the identifier of each available configuration.
func (m *Manager) ConfigurationIDs() []int {
	m.RLock()
	defer m.RUnlock()
	ids := make([]int, len(m.configs))
	for i := range m.configs {
		ids[i] = i
	}
	return ids
}

// ConfigurationGlobalIDs returns the global identifier of each available
// configuration.
func (m *Manager) ConfigurationGlobalIDs() []uint32 {
	m.RLock()
	defer m.RUnlock()
	gids := make([]uint32, len(m.configGidToID))
	for gid, id := range m.configGidToID {
		gids[id] = gid
	}
	return gids
}

// Configuration returns the configuration with the given identifier if
// present.
func (m *Manager) Configuration(id int) (config *Configuration, found bool) {
	m.RLock()
	defer m.RUnlock()
	if id < 0 || id >= len(m.configs) {
		return nil, false
	}
	config = m.configs[id]
	if config == nil {
		return nil, false
	}
	return config, true
}

// ConfigurationFromGlobalID returns the configuration with the given global
// identifier if present.
func (m *Manager) ConfigurationFromGlobalID(gid uint32) (config *Configuration, found bool) {
	m.RLock()
	defer m.RUnlock()
	localID, found := m.configGidToID[gid]
	if !found {
		return nil, false
	}
	return m.Configuration(localID)
}

// Configurations returns a slice of each available configuration.
func (m *Manager) Configurations() []*Configuration {
	m.RLock()
	defer m.RUnlock()
	cos := make([]*Configuration, len(m.configs))
	for i := range m.configs {
		cos[i] = m.configs[i]
	}
	return cos
}

// Size returns the number of nodes and configurations in the Manager.
func (m *Manager) Size() (nodes, configs int) {
	m.RLock()
	defer m.RUnlock()
	return len(m.nodes), len(m.configs)
}

// AddNode attempts to dial to the provide node address. The node is
// added to the Manager's pool of nodes if a connection was established.
func (m *Manager) AddNode(addr string) error {
	panic("not implemented")
}

// NewConfiguration returns a new configuration given a set of node ids and
// a quorum size. Any given gRPC call options will be used for every RPC
// invocation on the configuration.
func (m *Manager) NewConfiguration(ids []int, quorumSize int, timeout time.Duration) (*Configuration, error) {
	m.Lock()
	defer m.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one node")
	}
	if quorumSize > len(ids) || quorumSize < 1 {
		return nil, IllegalConfigError("invalid quourm size")
	}
	if timeout <= 0 {
		return nil, IllegalConfigError("timeout must be positive")
	}

	var cnodes []*Node
	for _, nid := range ids {
		if nid < 0 || nid >= len(m.nodes) {
			return nil, NodeNotFoundError(nid)
		}
		node := m.nodes[nid]
		if node == nil {
			return nil, NodeNotFoundError(nid)
		}
		if node.self && m.selfSpecified() {
			return nil, IllegalConfigError(
				fmt.Sprintf("self (%d) can't be part of a configuration when a self-option is provided", nid),
			)
		}
		cnodes = append(cnodes, node)
	}

	// Node ids are sorted by global id to
	// ensure a globally consistent configuration id.
	OrderedBy(GlobalID).Sort(cnodes)

	h := fnv.New32a()
	binary.Write(h, binary.LittleEndian, int64(quorumSize))
	binary.Write(h, binary.LittleEndian, timeout)
	for _, node := range cnodes {
		binary.Write(h, binary.LittleEndian, node.gid)
	}
	gcid := h.Sum32()

	cid, found := m.configGidToID[gcid]
	if found {
		if m.configs[cid] == nil {
			panic(fmt.Sprintf("config with gcid %d and cid %d was nil", gcid, cid))
		}
		return m.configs[cid], nil
	}
	cid = len(m.configs)

	c := &Configuration{
		id:		cid,
		gid:		gcid,
		nodes:		ids,
		mgr:		m,
		quorum:		quorumSize,
		timeout:	timeout,
	}
	m.configs = append(m.configs, c)

	return c, nil
}

func (m *Manager) selfSpecified() bool {
	return m.opts.selfAddr != "" || m.opts.selfGid != 0
}

/* node.go */

// Node encapsulates the state of a node on which a remote procedure call
// can be made.
type Node struct {
	// Only assigned at creation.
	id	int
	gid	uint32
	self	bool
	addr	string
	conn	*grpc.ClientConn

	sync.Mutex
	lastErr	error
	latency	time.Duration
}

func (n *Node) connect(opts ...grpc.DialOption) error {
	conn, err := grpc.Dial(n.addr, opts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %v", err)
	}
	n.conn = conn
	return nil
}

// ID returns the local ID of m.
func (n *Node) ID() int {
	return n.id
}

// GlobalID returns the global id of m.
func (n *Node) GlobalID() uint32 {
	return n.gid
}

// Address returns network address of m.
func (n *Node) Address() string {
	return n.addr
}

// ConnState returns the state of the underlying gRPC client connection.
func (n *Node) ConnState() (grpc.ConnectivityState, error) {
	return n.conn.State()
}

func (n *Node) String() string {
	n.Lock()
	defer n.Unlock()
	var connState string
	if n.conn == nil {
		connState = "nil"
	} else {
		cstate, err := n.conn.State()
		if err != nil {
			connState = err.Error()
		} else {
			connState = cstate.String()
		}
	}
	return fmt.Sprintf(
		"node %d | gid: %d | addr: %s | latency: %v | connstate: %v",
		n.id,
		n.gid,
		n.addr,
		n.latency,
		connState,
	)
}

func (n *Node) setLastErr(err error) {
	n.Lock()
	defer n.Unlock()
	n.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this node.
func (n *Node) LastErr() error {
	n.Lock()
	defer n.Unlock()
	return n.lastErr
}

func (n *Node) setLatency(lat time.Duration) {
	n.Lock()
	defer n.Unlock()
	n.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this node.
func (n *Node) Latency() time.Duration {
	n.Lock()
	defer n.Unlock()
	return n.latency
}

type lessFunc func(n1, n2 *Node) bool

// MultiSorter implements the Sort interface, sorting the nodes within.
type MultiSorter struct {
	nodes	[]*Node
	less	[]lessFunc
}

// Sort sorts the argument slice according to the less functions passed to
// OrderedBy.
func (ms *MultiSorter) Sort(nodes []*Node) {
	ms.nodes = nodes
	sort.Sort(ms)
}

// OrderedBy returns a Sorter that sorts using the less functions, in order.
// Call its Sort method to sort the data.
func OrderedBy(less ...lessFunc) *MultiSorter {
	return &MultiSorter{
		less: less,
	}
}

// Len is part of sort.Interface.
func (ms *MultiSorter) Len() int {
	return len(ms.nodes)
}

// Swap is part of sort.Interface.
func (ms *MultiSorter) Swap(i, j int) {
	ms.nodes[i], ms.nodes[j] = ms.nodes[j], ms.nodes[i]
}

// Less is part of sort.Interface. It is implemented by looping along the
// less functions until it finds a comparison that is either Less or
// !Less. Note that it can call the less functions twice per call. We
// could change the functions to return -1, 0, 1 and reduce the
// number of calls for greater efficiency: an exercise for the reader.
func (ms *MultiSorter) Less(i, j int) bool {
	p, q := ms.nodes[i], ms.nodes[j]
	// Try all but the last comparison.
	var k int
	for k = 0; k < len(ms.less)-1; k++ {
		less := ms.less[k]
		switch {
		case less(p, q):
			// p < q, so we have a decision.
			return true
		case less(q, p):
			// p > q, so we have a decision.
			return false
		}
		// p == q; try the next comparison.
	}
	// All comparisons to here said "equal", so just return whatever
	// the final comparison reports.
	return ms.less[k](p, q)
}

// ID sorts nodes by their local identifier in increasing order.
var ID = func(n1, n2 *Node) bool {
	return n1.id < n2.id
}

// GlobalID sorts nodes by their global identifier in increasing order.
var GlobalID = func(n1, n2 *Node) bool {
	return n1.gid < n2.gid
}

// Latency sorts nodes by latency in increasing order. Latencies less then
// zero (sentinel value) are considered greater than any positive latency.
var Latency = func(n1, n2 *Node) bool {
	if n1.latency < 0 {
		return false
	}
	return n1.latency < n2.latency

}

// Error sorts nodes by their LastErr() status in increasing order. A
// node with LastErr() != nil is larger than a node with LastErr() == nil.
var Error = func(n1, n2 *Node) bool {
	if n1.lastErr != nil && n2.lastErr == nil {
		return false
	}
	return true
}

// Connectivity sorts nodes by "best"/highest connectivity in increasing
// order. The (gRPC) connectivity status is ranked as follows:
// * Ready
// * Connecting
// * Idle
// * TransientFailure
// * Shutdown
var Connectivity = func(n1, n2 *Node) bool {
	n1State, n1Err := n1.conn.State()
	n2State, n2Err := n2.conn.State()
	switch {
	case n1Err != nil && n2Err == nil:
		return false
	case n1Err != nil && n2Err != nil:
		return true
	case n1Err == nil && n2Err != nil:
		return true
	case n1State <= grpc.Ready && n2State <= grpc.Ready:
		// Both are idle/connecting/ready.
		return n1State < n2State
	case n1State > grpc.Ready && n2State > grpc.Ready:
		// Both are transient/shutdown.
		return n1State > n2State
	case n1State > grpc.Ready && n2State < grpc.Ready:
		// n1 is transient/shutdown and n2 is idle/connecting/ready.
		return true
	default:
		// n2 is transient/shutdown and n1 is idle/connecting/ready.
		return false
	}
}

// Temporary to suppress varcheck warning.
var _ = Connectivity

/* opts.go */

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithGrpcDialOptions returns a ManagerOption which sets any gRPC dial options
// the Manager should use when initially connecting to each node in its
// pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = opts
	}
}

// WithLogger returns a ManagerOption which sets an optional error logger for
// the Manager.
func WithLogger(logger *log.Logger) ManagerOption {
	return func(o *managerOptions) {
		o.logger = logger
	}
}

// WithNoConnect returns a ManagerOption which instructs the Manager not to
// connect to any of its nodes. Mainly used for testing purposes.
func WithNoConnect() ManagerOption {
	return func(o *managerOptions) {
		o.noConnect = true
	}
}

// WithSelfAddr returns a ManagerOption which instructs the Manager not to connect
// to the node with network address addr. The address must be present in the
// list of node addresses provided to the Manager.
func WithSelfAddr(addr string) ManagerOption {
	return func(o *managerOptions) {
		o.selfAddr = addr
	}
}

// WithSelfGid returns a ManagerOption which instructs the Manager not to
// connect to the node with global id gid.  The node with the given
// global id must be present in the list of node addresses provided to the
// Manager.
func WithSelfGid(gid uint32) ManagerOption {
	return func(o *managerOptions) {
		o.selfGid = gid
	}
}

/* util.go */

func contains(addr string, addrs []string) (found bool, index int) {
	for i, a := range addrs {
		if addr == a {
			return true, i
		}
	}
	return false, -1
}
`
